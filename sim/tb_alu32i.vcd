$date
  Mon Feb 15 16:17:55 2021
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module riscv_32i $end
$upscope $end
$scope module helpers $end
$upscope $end
$scope module tb_helpers $end
$upscope $end
$scope module tb_alu32i $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$comment inst_enum_in is not handled $end
$var reg 32 # inst_in[31:0] $end
$var reg 32 $ inst_out[31:0] $end
$var reg 32 % rs1[31:0] $end
$var reg 32 & rs2[31:0] $end
$var reg 32 ' data_out[31:0] $end
$var reg 1 ( data_select $end
$var reg 1 ) jump $end
$var reg 32 * pc_out[31:0] $end
$var reg 32 + pc_in[31:0] $end
$var reg 1 , rw_memory $end
$var reg 2 - memory_size[1:0] $end
$var reg 32 . data_memory[31:0] $end
$var reg 32 / address_memory[31:0] $end
$var reg 1 0 tbclock $end
$var reg 1 1 tbsimended $end
$scope module dut $end
$var reg 1 2 clk $end
$var reg 1 3 rst $end
$comment inst_enum_in is not handled $end
$var reg 32 4 inst_in[31:0] $end
$var reg 32 5 inst_out[31:0] $end
$var reg 32 6 rs1[31:0] $end
$var reg 32 7 rs2[31:0] $end
$var reg 32 8 data_out[31:0] $end
$var reg 1 9 data_select $end
$var reg 1 : jump $end
$var reg 32 ; pc_out[31:0] $end
$var reg 32 < pc_in[31:0] $end
$var reg 1 = rw_memory $end
$var reg 2 > memory_size[1:0] $end
$var reg 32 ? data_memory[31:0] $end
$var reg 32 @ address_memory[31:0] $end
$var reg 1 A branch_select $end
$var reg 1 B integer_select $end
$var reg 32 C branch_data[31:0] $end
$var reg 32 D integer_data[31:0] $end
$scope module int_alu $end
$var reg 1 E clk $end
$var reg 1 F rst $end
$var reg 32 G inst_in[31:0] $end
$comment inst_enum_in is not handled $end
$var reg 32 H rs1_in[31:0] $end
$var reg 32 I rs2_in[31:0] $end
$var reg 32 J acc_out[31:0] $end
$var reg 1 K acc_me $end
$upscope $end
$scope module branch_alu $end
$var reg 1 L clk $end
$var reg 1 M rst $end
$var reg 1 N branch $end
$var reg 1 O misaligned $end
$comment inst_enum_in is not handled $end
$var reg 32 P inst_in[31:0] $end
$var reg 32 Q rs1_in[31:0] $end
$var reg 32 R rs2_in[31:0] $end
$var reg 32 S acc_out[31:0] $end
$var reg 32 T pc_in[31:0] $end
$var reg 32 U pc_out[31:0] $end
$var reg 1 V acc_me $end
$upscope $end
$scope module mem_alu $end
$var reg 1 W clk $end
$var reg 1 X rst $end
$comment inst_enum_in is not handled $end
$var reg 32 Y inst_in[31:0] $end
$var reg 32 Z inst_out[31:0] $end
$var reg 32 [ rs1_in[31:0] $end
$var reg 32 \ rs2_in[31:0] $end
$var reg 1 ] rw $end
$var reg 32 ^ data_store[31:0] $end
$var reg 32 _ address_out[31:0] $end
$var reg 2 ` mem_len[1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
0"
b00000000000000000000000000000000 #
b00000000000000000000000000000000 $
b00000000000000000000000000000000 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
0(
0)
b00000000000000000000000000000000 *
b00000000000000000000000000000000 +
0,
b00 -
b00000000000000000000000000000000 .
b00000000000000000000000000000000 /
00
01
02
03
b00000000000000000000000000000000 4
b00000000000000000000000000000000 5
b00000000000000000000000000000000 6
b00000000000000000000000000000000 7
b00000000000000000000000000000000 8
09
0:
b00000000000000000000000000000000 ;
b00000000000000000000000000000000 <
0=
b00 >
b00000000000000000000000000000000 ?
b00000000000000000000000000000000 @
0A
0B
b00000000000000000000000000000000 C
b00000000000000000000000000000000 D
0E
0F
b00000000000000000000000000000000 G
b00000000000000000000000000000000 H
b00000000000000000000000000000000 I
b00000000000000000000000000000000 J
0K
0L
0M
0N
0O
b00000000000000000000000000000000 P
b00000000000000000000000000000000 Q
b00000000000000000000000000000000 R
b00000000000000000000000000000000 S
b00000000000000000000000000000000 T
b00000000000000000000000000000000 U
0V
0W
0X
b00000000000000000000000000000000 Y
b00000000000000000000000000000000 Z
b00000000000000000000000000000000 [
b00000000000000000000000000000000 \
0]
b00000000000000000000000000000000 ^
b00000000000000000000000000000000 _
b00 `
#100000000
1"
13
1F
1M
1X
#200000000
#500000000
1!
10
12
1E
0K
1L
1W
#1000000000
0!
00
02
0E
0L
0W
#1200000000
#1500000000
1!
10
12
1E
0K
1L
1W
#2000000000
0!
00
02
0E
0L
0W
#2200000000
#2500000000
1!
10
12
1E
0K
1L
1W
#3000000000
0!
00
02
0E
0L
0W
#3200000000
#3500000000
1!
10
12
1E
0K
1L
1W
#4000000000
0!
00
02
0E
0L
0W
#4200000000
#4500000000
1!
10
12
1E
0K
1L
1W
#5000000000
0!
00
02
0E
0L
0W
#5200000000
#5500000000
1!
10
12
1E
0K
1L
1W
#6000000000
0!
00
02
0E
0L
0W
#6200000000
#6500000000
1!
10
12
1E
0K
1L
1W
#7000000000
0!
00
02
0E
0L
0W
#7200000000
#7500000000
1!
10
12
1E
0K
1L
1W
#8000000000
0!
00
02
0E
0L
0W
#8200000000
#8500000000
1!
10
12
1E
0K
1L
1W
#9000000000
0!
00
02
0E
0L
0W
#9200000000
#9500000000
1!
10
12
1E
0K
1L
1W
#10000000000
0!
00
02
0E
0L
0W
#10200000000
#10500000000
1!
10
12
1E
0K
1L
1W
#11000000000
0!
00
02
0E
0L
0W
#11200000000
11
